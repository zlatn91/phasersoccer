// -- user code here --
/* --- start generated code --- */
// Generated by  1.5.3 (Phaser v2.6.2)


/**
 * Level.
 */
function Level() {
	
	Phaser.State.call(this);
	
}

/** @type Phaser.State */
var Level_proto = Object.create(Phaser.State.prototype);
Level.prototype = Level_proto;
Level.prototype.constructor = Level;

Level.prototype.init = function () {
	this.stage.backgroundColor = '#ffffff';
	this.scale.pageAlignHorizontally = true;
	this.scale.pageAlignVertically = true;
};

Level.prototype.preload = function () {
	
//	this.load.pack('img', 'assets/pack.json');
	
};
Level.prototype.create = function () {
	bgm1.stop();
	startWhistle.play();
	var _field = this.add.sprite(480.0, 270.0, 'field');
	_field.anchor.setTo(0.5, 0.5);
	
	var _awayTeam = this.add.physicsGroup(Phaser.Physics.ARCADE);
	_awayTeam.position.setTo(-264.0, -36.0);
	_awayTeam.inputEnableChildren = true;
	
	var _korea1_5 = this.add.sprite(972.0, 312.0, 'korea2', null, _awayTeam);
	_korea1_5.anchor.setTo(0.5, 0.5);
	
	var _korea1_4 = this.add.sprite(1128.0, 312.0, 'korea2', null, _awayTeam);
	_korea1_4.anchor.setTo(0.5, 0.5);
	
	var _korea1_3 = this.add.sprite(984.0, 144.0, 'korea2', null, _awayTeam);
	_korea1_3.anchor.setTo(0.5, 0.5);
	
	var _korea1_2 = this.add.sprite(984.0, 468.0, 'korea2', null, _awayTeam);
	_korea1_2.anchor.setTo(0.5, 0.5);
	
	var _korea1_1 = this.add.sprite(876.0, 312.0, 'korea2', null, _awayTeam);
	_korea1_1.anchor.setTo(0.5, 0.5);
	
	var _homeTeam = this.add.physicsGroup(Phaser.Physics.ARCADE);
	_homeTeam.position.setTo(-258.0, -200.0);
	_homeTeam.inputEnableChildren = true;
	
	var _korea_5 = this.add.sprite(588.0, 396.0, 'korea', null, _homeTeam);
	_korea_5.anchor.setTo(0.5, 0.5);
	
	var _korea_4 = this.add.sprite(588.0, 552.0, 'korea', null, _homeTeam);
	_korea_4.anchor.setTo(0.5, 0.5);
	
	var _korea_3 = this.add.sprite(408.0, 348.0, 'korea', null, _homeTeam);
	_korea_3.anchor.setTo(0.5, 0.5);
	
	var _korea_2 = this.add.sprite(408.0, 588.0, 'korea', null, _homeTeam);
	_korea_2.anchor.setTo(0.5, 0.5);
	
	var _korea_1 = this.add.sprite(492.0, 468.0, 'korea', null, _homeTeam);
	_korea_1.anchor.setTo(0.5, 0.5);
	
	var _goal = this.add.physicsGroup(Phaser.Physics.ARCADE);
	
	var _goalPost = this.add.sprite(-87.0, 208.0, 'goalPost1', null, _goal);
	_goalPost.body.setSize(40.0, 60.0, 60.0, 30.0);
	_goalPost.body.moves = false;
	
	var _goalPost1 = this.add.sprite(944.0, 211.0, 'goalPost2', null, _goal);
	_goalPost1.body.setSize(40.0, 64.63397216796875, 0.0, 30.0);
	_goalPost1.body.moves = false;
	
	var _ball = this.add.sprite(480.0, 274.0, 'ball');
	this.game.physics.arcade.enable(_ball);
	_ball.anchor.setTo(0.5, 0.5);
	_ball.body.collideWorldBounds = true;
	_ball.body.bounce.x = 1;
	_ball.body.bounce.y = 0.7;
	_ball.body.maxVelocity.x = 900.0;
	_ball.body.maxVelocity.y = 900.0;
	_ball.body.drag.x = 300.0;
	_ball.body.drag.y = 300.0;
	_ball.body.friction.y = 1.0;
	_ball.body.maxAngular = 1000.0;
	
	_awayTeam.setAll("body.collideWorldBounds", true);
	_awayTeam.setAll("body.bounce.x", 0.9);
	_awayTeam.setAll("body.bounce.y", 0.6);
	_awayTeam.setAll("body.drag.x", 300);
	_awayTeam.setAll("body.drag.y", 300);
	_awayTeam.setAll("body.maxVelocity.x", 800);
	_awayTeam.setAll("body.maxVelocity.y", 800);
	_homeTeam.setAll("body.collideWorldBounds", true);
	_homeTeam.setAll("body.bounce.x", 0.9);
	_homeTeam.setAll("body.bounce.y", 0.6);
	_homeTeam.setAll("body.drag.x", 300);
	_homeTeam.setAll("body.drag.y", 300);
	_homeTeam.setAll("body.maxVelocity.x", 800);
	_homeTeam.setAll("body.maxVelocity.y", 800);
	
	
	// fields
	
	this.fField = _field;
	this.fAwayTeam = _awayTeam;
	this.fKorea1_5 = _korea1_5;
	this.fKorea1_4 = _korea1_4;
	this.fKorea1_3 = _korea1_3;
	this.fKorea1_2 = _korea1_2;
	this.fKorea1_1 = _korea1_1;
	this.fHomeTeam = _homeTeam;
	this.fKorea_5 = _korea_5;
	this.fKorea_4 = _korea_4;
	this.fKorea_3 = _korea_3;
	this.fKorea_2 = _korea_2;
	this.fKorea_1 = _korea_1;
	this.fGoalPost = _goalPost;
	this.fGoalPost1 = _goalPost1;
	this.fBall = _ball;
	this.fBall.body.onWorldBounds = new Phaser.Signal();
	this.fBall.body.onWorldBounds.add(setBounce, this);
//	this.fBall.body.onCollide = new Phaser.Signal();

	graphics2 = this.game.add.graphics(0, 0);
	graphics2.lineStyle(4, 0xffd900, 1);
	graphics3 = this.game.add.graphics(0, 0);
	graphics3.lineStyle(4, 0xA6EC8, 1);
	
//	this.game.input.mouse.mouseOutCallback = function() {	console.log("Mouse left game canvas");
	
	// 타이머 
	timer = this.game.time.create(true);
	timer.loop(5000, turnTimer, this);
	timer.start();
		
	
	this.fHomeTeam.onChildInputDown.add(set, this);
	this.fHomeTeam.onChildInputDown.add(setArrow, this);
	this.fHomeTeam.onChildInputUp.add(shoot, this);
	
	this.fAwayTeam.onChildInputDown.add(set, this);
	this.fAwayTeam.onChildInputDown.add(setArrow, this);
	this.fAwayTeam.onChildInputUp.add(shoot, this);
	
//	test(this.fHomeTeam.checkAll("body.velocity.x", 0));
	check(this);
	
};
/* --- end generated code --- */
// -- user code here --
let timer;
let fBall;
let arrow;

let mouseX;
let mouseY;
let homeTeamScore = 0;
let awayTeamScore = 0;
let team;
let kX;
let kY;
let bX;
let bY;
let length;
let kicker;
let ballSpeed;
let kickerSpeed;
let spin;


Level.prototype.update = function() {
	ballSpeed = parseInt(this.fBall.body.speed);
	
	// 화살표의 첫 색깔을 초록색으로  
	var color1 = [ 0, 255, 0 ];
	// 공의 정 가운데를 체크 
	bX = this.fBall.body.center.x;
	bY = this.fBall.body.center.y;
	// 마우스의 x,y를 판단 
	mouseX = this.game.input.activePointer.x;
	mouseY = this.game.input.activePointer.y;
	/*  
	 * 피타고라스의 정리를 활용하여 마우스를 처음 클릭한 좌표와 끌고온 좌표의 길이를 구함
	 * 마우스를 끌고온 x거리는 mouseX-arrow.X 의 제곱과 y거리 mouseY-arrow.y의 제곱을 Math.pow() 함수로 구하고 더해줌  
	 * 후에 Math.sqrt() 로 루트를 씌워 피타고라스 식을 완료 
	 */
	if (arrow !== undefined) {
		arrow.rotation = this.game.physics.arcade.angleToPointer(arrow);
		length = Math.pow((mouseX - arrow.x), 2)
				+ Math.pow((mouseY - arrow.y), 2);
		length = Math.sqrt(length);
		length = parseInt(length * 1.5);
		// legth를 정수로 만들어서 거리에 비례해 화살표의 크기를 변하게하고 color1,2 배열의 인덱스에 거리를 더해주면 색상이 변경
		if (length > 0 && length < 255) {
			arrow.scale.set(0 + length / 130, 0 + length / 130);
			var color = Phaser.Color.RGBtoString(color1[0] += length, color1[1] += -length, color1[2], '', '');
			arrow.tint = color;
		// 벌어진 거리가 크면 화면 흔들리는 효과를 넣어줌 
		} else if (length > 300) {
			this.game.camera.shake(0.003, 100);
		}
	}
	
	// 공과 골포스트가 오버랩 되면 score 메서드를 호출 하고 team 변수에 값을 넣어줌
	this.game.physics.arcade.overlap(this.fBall, this.fGoalPost, score, null,
			this, team = "away");
	this.game.physics.arcade.overlap(this.fBall, this.fGoalPost1, score, null,
			this, team = "home");
	
	// 공과 선수가 충돌시 banana 메서드를 호출
	this.game.physics.arcade.collide(this.fBall, this.fHomeTeam, banana, null,
			this);
	this.game.physics.arcade.collide(this.fBall, this.fAwayTeam, banana, null,
			this);
	
	// Home, Away 그룹은 자기 자신과 충돌
	this.game.physics.arcade.collide(this.fHomeTeam);
	this.game.physics.arcade.collide(this.fAwayTeam);
	
	// Home, Away 그룹은 서로 충돌 
	this.game.physics.arcade.collide(this.fHomeTeam, this.fAwayTeam);
	
//// 공의 스피드가 떨어지면 공의 가속도를 점차 감소시킴 
//	
//	if (speed !== 0) {
//		if (speed <= 200 && speed > 100) {
//			test("test0");
//			this.fBall.body.acceleration.x = 15;
//			this.fBall.body.acceleration.y = 15;
//		}
//		if(speed <= 100 && speed > 50){
//			test("test1");
//			this.fBall.body.acceleration.x = 10;
//			this.fBall.body.acceleration.y = 10;
//		}
//		if(speed <= 50){
//			test("test2");
//			this.fBall.body.acceleration.x = 0;
//			this.fBall.body.acceleration.y = 0;
//		}
//	}
	
	// 골대 앞에서 가만히 있는 플레이어가 있을시에는 200의 강도로 튕겨냄 
	for(var i=0; i<5; i++){
		if(this.fHomeTeam.children[i].body.center.x >= 0 && this.fHomeTeam.children[i].body.center.x <= 60){
			if(this.fHomeTeam.children[i].body.center.y >= 220 && this.fHomeTeam.children[i].body.center.y <= 320){
				this.fHomeTeam.children[i].body.velocity.set(ran(200, 400), ran(-200, -300));
			}
		}
		if(this.fAwayTeam.children[i].body.center.x >= 900 && this.fAwayTeam.children[i].body.center.x <= 960){
			if(this.fAwayTeam.children[i].body.center.y >= 220 && this.fAwayTeam.children[i].body.center.y <= 320){
				this.fAwayTeam.children[i].body.velocity.set(ran(-200, -400), ran(200, 300));
			}
		}
	}
	
	// 공이 구석에 박혀있을때 코너킥처럼 일정한 범위에서 랜덤값을 뽑아 튕겨냄 
	if (bX >= 0 && bX <= 60) {
		if (bY >= 0 && bY <= 60) {
			console.log("왼쪽상단구석");
			this.fBall.body.velocity.set(ran(200, 300), ran(200, 400));
		} else if (bY >= 480 && bY <= 540) {
			this.fBall.moves = false;
			console.log("왼쪽하단구석");
			this.fBall.body.velocity.set(ran(200, 300), ran(-400, -200));
		}
	}
	if (bX >= 900 && bX <= 960) {
		if (bY >= 0 && bY <= 60) {
			console.log("오른쪽상단구석");
			this.fBall.body.velocity.set(ran(-400, -200), ran(200, 400));
		} else if (bY >= 480 && bY <= 540) {
			console.log("오른쪽하단구석");
			this.fBall.body.velocity.set(ran(-300, -200), ran(-400, -200));
		}
	}

};
function showResult(){
	this.game.state.start("Result");
}

// 득점시 화면 흔들림후 공을 없애고 점수처리를 하는 메서드 
function score() {
	goal.play();
	var scoreTeam;
	this.game.camera.shake(0.005, 2000);
	this.fBall.kill();
	if (team == "home") {
		scoreTeam = this.add.sprite(0.0, 100.0, 'goal');
		scoreTeam.scale.set(0.5, 0.5);
		homeTeamScore += 1;
	} else {
		scoreTeam = this.add.sprite(400, 100.0, 'goal');
		scoreTeam.scale.set(0.5, 0.5);
		awayTeamScore += 1;
	}
	timer.add(8000, restart, this);
	// 어느 팀이든 2득점시 결과 캔버스를 보여줌 
	if(homeTeamScore == 2 || awayTeamScore == 2){
		endWhistle.play("", 0, 0.8, false, false);
		timer.add(7000, showResult, this);
	}
}

// 타이머, 점수를 화면에 표시함 
Level.prototype.render = function() {
	this.game.debug.text("Timer " + parseInt(timer.duration / 1000), 450, 32, 'white');
	this.game.debug.text("HomeTeam Score: " + homeTeamScore, 100, 50, 'green');
	this.game.debug.text("AwayTeam Score: " + awayTeamScore, 700, 50, 'red');
//	this.game.debug.bodyInfo(this.fBall, 32, 32);
};

// 플레이어와 공이 충돌하면 충돌 접점의 x,y를 이용해 감아차는 정도를 판단
function banana(fBall, kicker) {
	kick.play();
	fBall.body.acceleration.x = 0;
	fBall.body.acceleration.y = 0;
	if (kicker.body.speed > 450) {
		console.log("ky: " + kY + "  by: " + bY);
		if (kY > bY) {
			kicker.body.angularVelocity += 1000;
			kicker.body.angularDrag = 200;
			fBall.body.angularVelocity -= 1000;
			fBall.body.angularDrag = 300;	
			
			fBall.body.acceleration.y -= 300;
			
			fBall.body.velocity.y -= 50;
			}
		if (bY > kY) {
			kicker.body.angularVelocity -= 1000;
			kicker.body.angularDrag = 200;
			fBall.body.angularVelocity += 1000;
			fBall.body.angularDrag = 200;
			
			fBall.body.acceleration.y += 300;
			
			fBall.body.velocity.y += 50;
		}
		if (kX > bX) {
			kicker.body.angularVelocity = -1000;
			kicker.body.angularDrag = 200;
			fBall.body.angularVelocity = 1000;
			
			fBall.body.velocity.x -= 300;
			
			fBall.body.acceleration.x += -50;
		}
		if (bX > kX) {
			kicker.body.angularVelocity = 1000;
			kicker.body.angularDrag = 200;
			fBall.body.angularVelocity = -1000;
			
			fBall.body.acceleration.x += 300;
			
			fBall.body.velocity.x += 50;
			
		}
	}
	if (kicker.body.speed > 200 && kicker.body.speed < 400) {
		if (kY > bY) {
			kicker.body.angularVelocity = 200;
			kicker.body.angularDrag = 50;
			fBall.body.angularVelocity = -200;
			fBall.body.angularDrag = 50;
			fBall.body.acceleration.y -= 150;
		}
		if (bY > kY) {
			kicker.body.angularVelocity = -200;
			kicker.body.angularDrag = 50;
			fBall.body.angularVelocity = 200;
			fBall.body.angularDrag = 50;
			fBall.body.acceleration.y += 150;
		}
		if (kX > bX) {
			kicker.body.angularVelocity = -200;
			kicker.body.angularDrag = 50;
			fBall.body.angularVelocity += 200;
			fBall.body.angularDrag = 50;
				fBall.body.acceleration.x -= 150;
		}
		if (kX > bX) {
			kicker.body.angularVelocity += 200;
			kicker.body.angularDrag = 50;
			fBall.body.angularVelocity -= 200;
			fBall.body.angularDrag = 50;
				fBall.body.acceleration.x -= 150;
		}
	}
}


var bounce = 1;

function setBounce(fBall) {
	kick.play();
}
	
function setX(player) {
	centerX = player.body.center.x;
	return centerX;
}
function setY(player) {
	centerY = player.body.center.y;
	return centerY;
}

// 득점시 게임 재시작, cleaChache 를 fasle로 해야됨 
function restart() {
	timer.add(3000, turnTimer, this);
	this.game.state.restart('Level', false, this);
}
// 플레이어 클릭시 키커의 x와 y축의 센터부터 그려지게
function setArrow(kicker) {
	kX = kicker.body.center.x;
	kY = kicker.body.center.y;
	arrow = this.add.sprite(kX, kY, 'arrow');
	arrow.anchor.setTo(0, 0.5);
}
function set(kicker) {
	timer.pause();
	test("set");
	this.kicker = kicker;
	kicker.body.moves = false;
	kicker.body.velocity.setTo(0, 0);
}

// 키커가 어디 그룹에 속해있는지 판단하기 위해 만든 메서
function include (array, obj){
	for(var i=0; i<array.length; i++){
		if(array[i] == obj) {
			return true;
		}
	}
}

// 슛을 하면 타이머가 시작되고 슛의 강도를 정함 그리고 슛을 하게되면 플레이어의 태두리, 화살표를 지우는 메서드 
function shoot(kicker) {
	timer.resume();
	kicker.body.moves = true;
	kicker.body.velocity.setTo((arrow.x - mouseX) * 3, (arrow.y - mouseY) * 3);
	length = 0;
	if(include(this.fHomeTeam.children, kicker)) {
		graphics2.destroy();
	} else {
		graphics3.destroy();
	}
	arrow.destroy();
	arrow = undefined;
	check(this);
}

let j;
let flag = false;
// 두 그룹의 키커들의 동작이 모두 멈추었는지 체킹한다 
function check(Level){
	j = 0;
	if(Level.fBall.body.velocity.x == 0){
		for(var i=0; i<5; i++){
			if(Level.fHomeTeam.children[i].body.velocity.x === 0 && Level.fAwayTeam.children[i].body.velocity.x === 0 ){
				if(i===4){
					timer.start();
					flag = true;
				}
				
			}
		}
	}
}

var turn = 1;

function turnTimer() {
	check(this);
	if(flag){
		if (turn % 2 === 1 || turn === 1) {
			test("turntimer: " + turn);
			this.fHomeTeam.onChildInputDown.active = true;
			this.fHomeTeam.onChildInputUp.active = true;
			this.fAwayTeam.onChildInputDown.active = false;
			this.fAwayTeam.onChildInputUp.active = false;
			graphics3.destroy();
			graphics2 = this.game.add.graphics(0, 0);
			graphics2.lineStyle(4, 0xffd900, 1);
			graphics2.drawCircle(setX(this.fKorea_1), setY(this.fKorea_1), 32);
			graphics2.drawCircle(setX(this.fKorea_2), setY(this.fKorea_2), 32);
			graphics2.drawCircle(setX(this.fKorea_3), setY(this.fKorea_3), 32);
			graphics2.drawCircle(setX(this.fKorea_4), setY(this.fKorea_4), 32);
			graphics2.drawCircle(setX(this.fKorea_5), setY(this.fKorea_5), 32);
		} else if ( turn % 2 === 0){
			this.fAwayTeam.onChildInputDown.active = true;
			this.fAwayTeam.onChildInputUp.active = true;
			this.fHomeTeam.onChildInputDown.active = false;
			this.fHomeTeam.onChildInputUp.active = false;
			graphics2.destroy();
			graphics3 = this.game.add.graphics(0, 0);
			graphics3.lineStyle(4, 0xA6EC8, 1);
			graphics3.drawCircle(setX(this.fKorea1_1), setY(this.fKorea1_1), 32);
			graphics3.drawCircle(setX(this.fKorea1_2), setY(this.fKorea1_2), 32);
			graphics3.drawCircle(setX(this.fKorea1_3), setY(this.fKorea1_3), 32);
			graphics3.drawCircle(setX(this.fKorea1_4), setY(this.fKorea1_4), 32);
			graphics3.drawCircle(setX(this.fKorea1_5), setY(this.fKorea1_5), 32);
		}
		turn+=1;
	}
	
}
// console.log를 간편하게 쓸 수 있게 작성한 메서드 
function test(article) {
	console.log("#### test: " + article);
}

// 최소 최대값을 받아 그 범위의 랜덤수를 뽑아주는 역할 
function ran(min, max) {
	let ran2 = Phaser.Math.between(min, max);
	return ran2;
}
